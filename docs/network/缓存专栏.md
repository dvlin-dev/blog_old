---
titile: 缓存专栏
---

<!-- > 缓存的关键主要包括 request method 和目标 URI（一般只有 GET 请求才会被缓存）。 -->

# 前端到底有哪些缓存？

## 按照失效策略划分可以分为：

- 强缓存
- 协商缓存

## 浏览器缓存按照缓存位置划分可以分为：

- Service Worker Cache
- Memory Cache
- Disk Cache
- Push Cache

##  存储型缓存 
Cookie、Web Storage、IndexedDB 等

## other
CDN 缓存属于服务端缓存

# http 缓存

<img src="/Users/zhihu1/code/blog/docs/assets/image-20220808102300643.png" alt="image-20220808102300643"  />

## 强缓存
强缓存存储的时间

### Expires

**Expires** 是过期时间戳，其给出了缓存过期的**绝对时间**。

#### 示例

```
Expires: Wed, 11 May 2022 03:50:47 GMT
```

### Cache-Control

Cache-Control 首部字段是 `HTTP/1.1` 中定义缓存的字段，其用于控制缓存的行为，可以组合使用多种指令，多个指令之间可以通过 “,” 分隔，属于**通用首部字段**。常用的指令有：max-age、s-maxage、public/private、no-cache/no store 等。

**速查表：**

| 指令              | 参数   | 说明                                           |
| ----------------- | ------ | ---------------------------------------------- |
| public            | 无     | 可向任一方提供响应的缓存                       |
| private           | 可省略 | 仅向特定用户返回响应                           |
| no-cache          | 可省略 | 缓存前必须先确定其有效性                       |
| no-store          | 无     | 不缓存请求或响应的任何内容                     |
| no-transform      | 无     | 代理不可更改媒体类型                           |
| must-revalidate   | 无     | 可缓存但必须再向源服务器进行确认               |
| proxy-revalidate  | 无     | 要求中间缓存服务器对缓存的响应有效性在进行确认 |
| max-age = [ 秒 ]  | 必需   | 响应额最大 Age 值                              |
| s-maxage = [ 秒 ] | 必需   | 公共缓存服务器响应的最大 Age 值                |
| cache-extension   | -      | 新指令标记（token）                            |

#### 示例

```
Cache-Control: max-age:3600, s-maxage=3600, public
Cache-Control: no-cache
```

#### max-age

`max-age` 指令给出了缓存过期的**相对时间**，单位为秒数。当其与 Expires 同时出现时，**max-age 的优先级更高**。但往往为了做向下兼容，两者都会经常出现在响应首部中。

同时 max-age 还可在请求首部中被使用，告知服务器客户端希望接收一个存在时间（age）不大于多少秒的资源。

> **修改电脑时间，缓存会收到影响吗 ？**
>
> **expires “不精准” 是因为它的值是一个绝对时间，而 max-age 与其相反却是一个相对时间****
>
> 但是一旦修改了电脑客户端本地时间为未来时间，缓存使用期的计算便会受到影响，主要是**停留缓存时间**会变大，从而导致缓存使用期超出缓存新鲜度范围（强缓存失效）。这便是 max-age 仍然受到本地时间影响的原因所在。
>
> 
>
> 缓存新鲜度 = max-age || (expires - date)
>
> 缓存使用期 = 响应使用期 + 传输延迟时间 + **停留缓存时间**
>
> 强缓存是否新鲜 = 缓存新鲜度 > 缓存使用期

#### s-maxage

而 `s-maxage` 与 max-age 不同之处在于，其只适用于公共缓存服务器，比如资源从源服务器发出后又被中间的代理服务器接收并缓存。

**当使用 s-maxage 指令后，公共缓存服务器将直接忽略 Expires 和 max-age 指令的值**

#### public/private

`public` 指令表示该资源可以被任何节点缓存（包括客户端和代理服务器），

与其行为相反的 `private` 指令表示该资源只提供给客户端缓存，代理服务器不会进行缓存。

**同时当设置了 private 指令后 s-maxage 指令将被忽略。**

#### no-cache/no store

> 从字面意思上很容易把no-cache误解成为不缓存，但事实上no-cache代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为do-not-serve-from-cache-without-revalidation更合适。no-store才是真正地不进行缓存。

>  使用no-cache指令的目的是为了防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。

**这两个指令在请求和响应中都可以使用**，两者看上去都代表不缓存，但在响应首部中被使用时， `no store` 才是真正的不进行任何缓存。

当 no-cache 在请求首部中被使用时，表示告知（代理）服务器不直接使用缓存，要求向源服务器发起请求，而当在响应首部中被返回时，表示客户端可以缓存资源，但每次使用缓存资源前都**必须**先向服务器确认其有效性，这对每次访问都需要确认身份的应用来说很有用。

当然，我们也可以在代码里加入 meta 标签的方式来修改资源的请求首部：

```html
<meta http-equiv="Cache-Control" content="no-cache" />
```



## 协商缓存

#### Last-Modified 与 If-Modified-Since

Last-Modified 首部字段顾名思义，代表资源的最后修改时间，其属于**响应首部字段**。当浏览器第一次接收到服务器返回资源的 Last-Modified 值后，其会把这个值存储起来，并再下次访问该资源时通过携带 If-Modified-Since 请求首部发送给服务器验证该资源有没有过期。

**示例：**

```
Last-Modified: Fri , 14 May 2021 17:23:13 GMT
If-Modified-Since: Fri , 14 May 2021 17:23:13 GMT
```

如果在 If-Modified-Since 字段指定的时间之后**资源发生了更新**，那么服务器会将更新的资源发送给浏览器（状态码200）并返回最新的 Last-Modified 值，浏览器收到资源后会更新缓存的 If-Modified-Since 的值。

如果在 If-Modified-Since 字段指定的时间之后**资源都没有发生更新**，那么服务器会返回状态码 `304 Not Modified` 的响应。

> **那么 last-modified 有会什么弊端？服务器进行对比时一定精准吗？**
>
> last-modified 是一个时间，最小单位为秒，试想一下，如果资源的修改时间非常快，快到毫秒级别，那么服务器会误认为该资源仍然是没有修改的，这便导致了资源无法在浏览器及时更新的现象。
>
> 另外还有一种情况，比如服务器资源确实被编辑了，但是其实资源的实质内容并没有被修改，那么服务器还是会返回最新的 last-modified 时间值，但是我们并不希望浏览器认为这个资源被修改而重新加载。
>
> 为了避免以上现象的发生，在特殊的场景下，我们便需要使用 eTag。

#### Etag 与 If-None-Match

Etag 首部字段用于代表资源的唯一性标识，服务器会按照指定的规则生成资源的标识，其属于**响应首部字段**。当资源发生变化时，Etag 的标识也会更新。同样的，当浏览器第一次接收到服务器返回资源的 Etag 值后，其会把这个值存储起来，并在下次访问该资源时通过携带 If-None-Match 请求首部发送给服务器验证该资源有没有过期。

**示例：**

```
Etag: "29322-09SpAhH3nXWd8KIVqB10hSSz66"
If-None-Match: "29322-09SpAhH3nXWd8KIVqB10hSSz66"
```

如果服务器发现 If-None-Match 值与 Etag 不一致时，说明服务器上的文件已经被更新，那么服务器会发送更新后的资源给浏览器并返回最新的 Etag 值，浏览器收到资源后会更新缓存的 If-None-Match 的值。

> 同时设置 **Last-Modified** 和 **Etag** ，**Etag** 的优先级更高

eTag 值有两种方式:

- **使用文件大小和修改时间**；
- **使用文件内容的 hash 值和内容长度**。

通过上述方法生成的 eTag 也被称为**强 eTag 值**，其不论实体发生多么细微的变化都会改变它的值。那么与其对立的便是**弱 eTag 值**，在 eTag 包源码中我们可以发现通过传递第二个参数 `weak` 值为 `true` 时便可启用弱校验。

弱 ETag 值只适用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时会在字段值最开始处附加 W/。

```http
ETag: W/"29322-09SpAhH3nXWd8KIVqB10hSSz66"
```

## 启发式缓存

如果`Expires`, `Cache-Control: max-age`, 或 `Cache-Control:s-maxage` 都没有在响应头中出现, 并且也没有其它缓存的设置, 那么浏览器默认会采用一个**启发式的算法**, 通常会取响应头的`Date_value - Last-Modified_value`值的10%作为缓存时间。（更多资料可参考：[Caching in HTTP](https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.2.4)）

```
缓存新鲜度 = max(0,（date - last-modified)) * 10%
```

## HTTP 缓存方案解析

当我们访问一个网站时，浏览器率先加载的便是 HTML 文件，后续继续加载一些首页渲染需要以及公共的资源文件，**刷新页面或再次访问时大部分资源都命中了强缓存，唯独率先加载的 HTML 资源走了协商缓存，这是为什么？**

因为像 JS、CSS 等资源经过像 `webpack` 这样的打包工具打包后可以自动生成 `hash` 文件名，每次部署到服务器上后发生变化的资源 hash 名会更新，浏览器会当作一个新的资源去向服务器请求，没有更新的资源便会优先读取浏览器缓存。

而 HTML 不同，其文件名不会改变，我们期望浏览器每次加载时都应该向服务器询问是否更新，否则会出现新版本发布后浏览器读取缓存 HTML 文件导致页面空白报错（旧资源被删除）或应用没有更新（读取了旧资源）的问题。

根据 HTTP 缓存的规则最终我们便可以总结出如下缓存方案：

- **频繁变动的资源，比如 HTML， 采用协商缓存**
- **CSS、JS、图片资源等采用强缓存，使用 hash 命名**

关于如何让 HTML 文件走协商缓存，**前提得先让浏览器强缓存失效**，可以设置如下服务器响应报头：

```
Cache-Control: max-age=0
Last-Modified: Sat, 04 Sep 2021 08:59:40 GMT
```

### Webpack 中的 Hash 模式

在 webpack 中 hash 可以分为三种类型：**hash、chunkhash、contenthash**

#### hash

`hash` 属于项目级别的 hash，意思就是整个项目中只要有文件改变该 hash 值就会变化，同时所有文件也都共用该 hash 值。

#### chunkhash

`chunkhash` 与 hash 不同，其属于入口文件级别的 hash，会根据入口文件（entry）的依赖进行打包，分包后为每个 chunk 生成 hash

#### contenthash

`contenthash` 是属于文件内容级别的 hash，其会根据文件内容的变化而变化，一般用于解决以下问题：

比如 home.js 中单独引入了 home.css 文件，那么当 js 文件被修改后，就算 css 文件并没有被修改，由于该模块发生了改变，同样会导致 css 文件也被重复构建。此时，针对 css 使用 contenthash 后，只要其内容不变就不会被重复构建。

**tips：当在 module 中使用 loader 设置图片或者字体的文件名时，如包含 hash 或 chunkhash 都是不生效的，默认会使用 contenthash。**



**将 chunkhash 和 contenthash 组合使用才能最大化的利用 HTTP 缓存中强缓存的优势，减少不必要的资源重复请求，提升网页的整体打开速度。**

## 用户操作与 HTTP 缓存

当我们打开开发者工具，在浏览器刷新按钮上右键鼠标便会展示这几种模式，如下图所示：

![image-20220808164622179](/Users/zhihu1/code/blog/docs/assets/image-20220808164622179.png)

### 正常重新加载

```
// 快捷键
Mac: Command + R
Windows: Ctrl + R（等同于直接按 F5）
```

大多数资源会命中强缓存

### 硬性重新加载

```shell
// 快捷键
Mac: Command + Shift + R
Windows: Ctrl + Shift + R（等同于直接按 Ctrl + F5）
```

硬性重新加载后所有资源的请求首部都被加上了 `cache-control: no-cache` 和 `pragma: no-cache`，两者的作用都表示告知（代理）服务器不直接使用缓存，要求向源服务器发起请求，而 pragma 则是为了兼容 HTTP/1.0。

因此**硬性重新加载并没有清空缓存，而是禁用缓存**，其效果类似于在开发者工具 Network 面板勾选了 `Disable cache` 选项。

### 清空缓存并硬性重新加载

该模式顾名思义，其比硬性重新加载多了清空缓存的操作，因此**触发该操作会将浏览器存储的本地缓存都清空掉后再重新向服务器发送请求**，同时其影响的并不是当前网站，所有访问过的网站缓存都将被清除。

### 为什么硬性重新加载后还是命中了缓存

base64 图片会触发这种情况。

从本质上看 base64 图片其实就是一堆字符串，其伴随着页面的渲染而加载，浏览器会对其进行解析，会损耗一定的性能。按照浏览器的“节约原则”。Base64 格式的图片被塞进 memory cache 可以视作浏览器为节省渲染开销的“自保行为”。

>  **tips：如果采用开发者工具 Network 面板勾选 `Disable cache` 选项方式，那么异步资源也不会读取缓存，原因是缓存被提前禁用了，这与硬性重新加载不同。**

# 浏览器缓存

## Service Worker

**Service Worker 缓存是持久的，独立于浏览器缓存或网络状态。** 

> 该部分内容过多，需要单出一篇文章来讲解。

## Memory Cache

**内存缓存**其优点为获取速度快、优先级高，从内存中获取资源耗时为 0 ms，而其缺点也显而易见，比如生命周期短，当网页关闭后内存就会释放，同时虽然内存非常高效，但它也受限制于计算机内存的大小，是有限的。

> 内存缓存虽然快，但是使用要适当，内存缓存不在垃圾回收范围内，再加上 V8 分配的内存有限，处理不当容易导致内存泄漏。

> 浏览器内存缓存生效的前提下，JS 资源的执行加载时间会影响其是否被内存缓存，时间过长会走 DIsk Cache
>
> 此外图片资源（非 base64）也有和 JS 资源同样的现象，
>
> 而 CSS 资源比较与众不同，其被磁盘缓存的概率远大于被内存缓存。
>
> 非标准答案：
>
> 因为 CSS 文件加载一次就可渲染出来，我们不会频繁读取它，所以它不适合缓存到内存中，但是 JS 之类的脚本却随时可能会执行，如果脚本在磁盘当中，我们在执行脚本的时候需要从磁盘取到内存中来，这样 IO 开销就很大了，有可能导致浏览器失去响应。

## Disk Cache

**磁盘缓存**它的优缺点与 Memory Cache 正好相反，比如优点是生命周期长，不触发删除操作则一直存在，而缺点则是获取资源的速度相对内存缓存较慢。

## Push Cache

即推送缓存，这是浏览器缓存的最后一道防线。它是 `HTTP/2` 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。关于 Push Cache，有非常多的内容可以挖掘，不过这已经不是本文的重点，大家可以参考这篇[扩展文章](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)。

## 存储型缓存 

浏览器存储型缓存包含了 **Cookie**、**Web Storage**、**IndexedDB** 等

### Cookie

**Cookie 的存储空间很小，不能超过 4KB。**

Cookie 在每次请求中都会携带，其出现是为了解决 HTTP 没有状态的缺陷。

而利用 Cookie 无法跨域携带的特点我们可以在 CDN 域名上有所作为。假如 CDN 资源和主站采用了同样的域名，那么必然会造成因 Cookie 传输带来的巨大性能浪费，相反我们可以将 CDN 的域名与主站区分开来来规避这一问题。

**服务端**可以在返回前端的响应报头中设置首部字段 `set-cookie` 将信息植入浏览器 cookie 中。

set-cookie 指令值包含了必选项 `<cookie-name>=<cookie-value>` 值和名的形式，同时还包括了可选项 Path（路径）、Domain（域名）、Max-Age（有效时间）等，以分号分隔。

服务端可以返回多个 set-cookie 指令来达到设置多个 cookie 的目的。

**客户端**通过 document.cookie 获取和操作 Cookie

### Web Storage

Web Storage 作为 HTML5 推出的浏览器存储机制，其又可分为 `Session Storage` 和 `Local Storage ` 。

Web Storage 与 Cookie 相比存储大小得到了明显的提升，一般为 2.5-10M 之间（各家浏览器不同）。

### IndexedDB

IndexedDB 是一个大规模的 NoSQL 存储系统，它几乎可以存储浏览器中的任何数据内容，包括二进制数据（ArrayBuffer 对象和 Blob 对象），其可以存储不少于 250M 的数据。理论上无上限，但是当磁盘内存不足时 IndexedDB 会被删除。

原生 API 操作比较繁琐，推荐使用 [idb](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fidb) 

## Preload 、Prefetch和缓存位置

preload 也被称为预加载，其用于 link 标签中，可以指明哪些资源是在页面加载完成后即刻需要的，浏览器会在主渲染机制介入前预先加载这些资源，并不阻塞页面的初步渲染。例如：

```html
<link rel="preload" href="https://xx/sdk.js" as="script" />
```

而当使用 **preload** 预加载资源后，该资源一直会从**磁盘缓存中**读取，JS、CSS 及图片资源都有同样的表现，这主要还是和资源的**渲染时机有关，在渲染机制还没有介入前的资源加载不会被内存缓存**。

相反 prefetch 则表示预提取，告诉浏览器加载下一页面可能会用到的资源，浏览器会利用空闲状态进行下载并将资源存储到缓存中。

```html
<link rel="prefetch" href="https://xx/sdk.js" />
```

使用 **prefetch** 加载的资源，刷新页面时大概率会从**磁盘缓存**中读取，如果跳转到使用它的页面，则直接会从磁盘中加载该资源。

# 参考

- 《前端缓存技术方案解析》- 掘金小册
- 《图解 HTTP 》
